#+title: Features

* DONE ~dockerfile~ component type to ~add~ command

+ Default Dockerfile implementation
+ Should check if one already exists and output error if so
+ User should be able to run ~gotm add dockerfile~ and having a perfectly working image
  + E.g. compiled with ~CGO=1~ so that sqlite works as intended

Dockerfile should be semi-optimized
+ e.g. small as runner image
  + Two builders, one for frontend and one for backend
+ optimised for caching, e.g. package*.json files loaded and npm install first for fast rebuilds

* TODO database intergration

An evolution of the previous ~db~ command.

Decided to use sqlc for database intergration... this stack should be easy to
use and get out of your way. SQLC matches that. Using goose for migration management
also seems like a logical choice as well

Deciding on sqlc meant that there only needs to be a few things for it to be setup in
a gotm application;
+ A ~migrations/~ folder containing migrations that build the state of your database
  sqlc looks at this to determine its models
+ A ~queries/~ folder containing the queries for sqlc to generate its code on.
+ ~sqlc.yml~ in the project directory defining the above directories and other options,
  e.g. whether to generate json tags for the models (Want to ensure this is implemented)

From there, I believe the ~db~ subcommand can be simplified and added to the existing
~add~ command, depending on the implementation of the commands. The only two things
the programming will be doing that will be supported by the cli tool will be:
1. Adding tables to the database
2. Adding migrations for finer control

Essentially these are two "components", which is a concept that already exists within the
application. The implementation of each component generation is below:

** ~migration~ component

Starting with the simpler of the two, there's not much logic here. In fact all of the logic
for this is already in the application for all the other component generation

This should generate a template file in the correct location, i.e. ~gotm add migration example~
should generate the file ~migrations/example.sql~.

It will likely be used for finer operation requiring manual intervention, i.e modifying an
existing table

** ~table~ component

This one is a little more complicated. I want this component to do the following things
+ Generate a migration creating the table with the given name and fields called in the command
+ Generate a file of basic CRUD SQL queries for the newly created table
+ Ensure ~sqlc.yml~ is present, generating a sensible default one if not
+ Running ~sqlc generate~ to generate the code for use in the project

This command can calling sqlc generate as we can ensure all three requirements for it to run
will be present after running the command.

As for how the fields will be defined, I'm thinking a key=value situation within the command line,
e.g. ~gotm add table book title=text author=text publishedAt=int64~
+ Not sure how to handle things like ~NOT NULL~ markings

There could be some standard fields:
+ ~id~ will be the primary key (Need to look into how bad autoincrementing is?)
+ ~createdAt~ will be a Unix timestamp that will be populated when an object in inserted into a row (In the autogenerated SQL query)
+ ~updatedAt~ does what it says on the tin, same as createdAt except updated when the row is updated

NOTE: the intention of this feature is to not handle complex cases. In those complex cases, the programmer
will have to modify the generated files/not use this feature. However this will catch a lot of stuff,
especially in projects where this tool will be used

* SCRAPPED ~db~ command

Handles everything to do with adding a database to the project

Database will handle using `sqlite`
+ everything about this program is catering to a specific opinionated stack.. this will be no different


It will have several subcommands (likely implemented as separate controllers?)

** SCRAPPED ~init~

+ Install sqlite3 driver in go project (Probably via running the command)
+ Creates ~repositories/sqlite.go~ (Fails if exists) containing ~SqliteRepository~ struct
+ Default implementation for an sqlite database (including some kind of migration manager?)
  + Might need to program a simple one?

** SCRAPPED ~add~

+ Similar to ~gotm add~ command
+ Allows the user to expand the database

*** TODO ~table~

Adds a table with the given fields to the database

Does two things
1. Generate a basic migration file to add the file
2. Generates basic methods on ~SqliteRepository~ for C.R.U.D operations with the file
   + This only covers the basic case, *NOT HANDLING RELATIONAL TABLES*
   + Trying to make this too smart will add too many knobs for it to be fast and easy to use

Maybe, depending on file structure within the repository, a check is done to see if a table with that name already exists?

Example: ~gotm db add table users --fields username=string password_hash=string created_at=int updated_at=int~
    

*** TODO ~migration~

Just creates a migration file in the correct spot and with the correct timestamp

+ Ideal for database changes that don't involve a new table
